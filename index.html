<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Прототип карточного города</title>
<style>
body { font-family: sans-serif; text-align: center; }
#score { margin-top: 10px; font-size: 18px; }
#info { margin-top: 10px; font-size: 16px; }
#quests { margin-top: 10px; text-align: left; display: inline-block; }
#grid {
  display: grid;
  grid-template-columns: repeat(10, 40px);
  grid-gap: 2px;
  justify-content: center;
  margin-top: 20px;
  width: max-content;
  margin-left: auto;
  margin-right: auto;
}
.preview {position: absolute;inset: 0;pointer-events: none;}
.cell { width: 40px; height: 40px; border: 1px solid #aaa; display: flex; align-items: center; justify-content: center; font-size: 10px; position: relative; }
.highlight { outline: 3px solid yellow; }
.block-layer { position: absolute; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 9px; }
.residential { background: #8fd18f; }
.industrial { background: #d18f8f; }
.nature { background: #8fc3d1; }
.culture { background: #d1c08f; }
#hand { margin-top: 20px; display: flex; justify-content: center; }
.card { width: 80px; height: 80px; margin: 0 5px; cursor: pointer; border: 2px solid #333; display: flex; flex-wrap: wrap; transition: transform 0.2s ease; transform-origin: center center;}
.block { width: 40px; height: 40px; box-sizing: border-box; border: 1px solid #555; display: flex; align-items: center; justify-content: center; font-size: 9px; }
.selected { border-color: red; }
.residential-text { color: #0b5; font-weight: bold; }
.industrial-text { color: #b33; font-weight: bold; }
.nature-text { color: #09c; font-weight: bold; }
.culture-text { color: #c90; font-weight: bold; }
#message { margin-top: 10px; font-size: 16px; min-height: 30px; }

/* === styles for quest cards (added) === */
#left-panel {
  width: 260px;
  display: inline-block;
  vertical-align: top;
  text-align: left;
  margin-right: 20px;
}
#quests {
  display: flex;
  flex-direction: column;
  gap: 15px;
}
.quest-card {
  position: relative; /* <-- это нужно для абсолютного бейджа */
  border: 2px solid #555;
  border-radius: 10px;
  padding: 10px;
  background: #f4f4f4;
  box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
}
.quest-title { font-weight: bold; margin-bottom: 5px; }
.quest-reward { font-size: 12px; color: #090; }
.quest-desc { font-size: 13px; margin-bottom: 8px; }
.progress-container { width: 100%; height: 16px; background: #ddd; border-radius: 6px; overflow: hidden; position: relative; }
.progress-bar { height: 100%; background: linear-gradient(90deg, #3c8, #4c4); width: 0%; transition: width 0.3s ease; }
.completed { border-color: gold; background: #fffbe0; }
.quest-reward-badge {
  position: absolute;
  top: 5px;
  right: 5px;
  background: gold;
  color: black;
  font-weight: bold;
  border-radius: 50%;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
  pointer-events: none;
}

#hand-wrapper {
  display: flex;
  justify-content: center;
  align-items: center; /* центрируем колоду и рукав по высоте */
  gap: 20px;
}

#deck-counter {
  display: flex;
  flex-direction: column; /* если нужен текст сверху/цифра снизу */
  justify-content: center; /* центрируем контент внутри */
  align-items: center;
  flex-shrink: 0; /* не сжимать */
  width: 80px;
  height: 80px;
  border: 2px dashed #555;
  border-radius: 8px;
  background: #fafafa;
  color: #333;
  font-size: 14px;
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  line-height: 1;
  transform: translateY(10px); /* подогнать визуально */
}

#deck-counter * {
  margin: 0;
  padding: 0;
  line-height: 1; /* гарантируем отсутствие смещений текста */
}

#hand {
  display: flex;
  gap: 5px;
  align-items: center; /* центрируем карты по вертикали */
}




#deck-counter span.count {
  font-size: 24px;  /* большая цифра */
  font-weight: bold;
  line-height: 1;
}


</style>
</head>
<body>

<h1>Прототип карточного города</h1>
<div id="left-panel">
  <h3>Квесты</h3>
  <div id="quests"></div>
</div>
<div style="display:inline-block; vertical-align: top;">
  <div id="score">Очки: 0</div>
  <div id="info"></div>
  <div id="grid"></div>
  <h3>Рука</h3>
  <div id="hand-wrapper">
  <div id="deck-counter">В колоде: 0</div>
  <div id="hand"></div>
</div>

<div id="message">
  <div id="msg-event-log" style="max-height: 200px; overflow-y: auto;"></div>
</div>
</div>

<script>
const gridSize = 10;
let grid = Array.from({length: gridSize}, () => Array.from({length: gridSize}, () => null));
const gridDiv = document.getElementById('grid');

let lastHoverX, lastHoverY; // хранит последнюю ячейку, на которой был курсор

for (let y = 0; y < gridSize; y++) {
  for (let x = 0; x < gridSize; x++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.dataset.x = x;
    cell.dataset.y = y;
    gridDiv.appendChild(cell);
    cell.addEventListener('mouseenter', () => {
      lastHoverX = x; lastHoverY = y;
      highlightArea(x, y);
    });
    cell.addEventListener('mouseleave', () => {
      clearHighlights();
      // оставляем lastHoverX/Y, чтобы можно было обновить превью при повороте
    });
    cell.addEventListener('click', () => placeCard(x, y));
  }
}

let selectedCardIndex = null;
let cardRotation = 0; // глобальная ориентация текущей выбранной карты (0..3)
let cardRotations = []; // индивидуальные повороты карт в руке (не обязателен, но оставлен)
let deck = [];
let hand = [];
let activeQuests = [];
let completedQuests = [];
let completedQuestPoints = {};
let savedPoints = 0;
let lastScore = 0;
let prevScore = 0;
let nextCardThreshold = 3;
let nextQuestThreshold = 10;
const msgScore = document.getElementById('msg-score');
const msgEvent = document.getElementById('msg-event');

const initialHandSize = 12;

// визуальные квесты (отдельно, для карточек)
const quests = [
  {
    name: "Город в зелени",
    reward: 3,
    goal: 10,
    progress: 0,
    desc: "За каждый дом, соседствующий с парком, +2 очка. За дом без парка рядом — −2 очка."
  },
  {
    name: "Баланс индустрии",
    reward: 4,
    goal: 12,
    progress: 0,
    desc: "Заводы приносят по +2 очка, если рядом хотя бы один дом и один парк. Если рядом только дома — −2 очка."
  },
  {
    name: "Комфортные окраины",
    reward: 4,
    goal: 10,
    progress: 0,
    desc: "Дома на краю поля дают +2 очка, но только если не касаются заводов."
  },
  {
    name: "Сердце культуры",
    reward: 6,
    goal: 15,
    progress: 2,
    desc: "Получай +3 очка за каждый культурный блок, соседствующий со всеми 4-мя видами кварталов."
  },
  {
    name: "Пояс жизни",
    reward: 3,
    goal: 12,
    progress: 8,
    desc: "Получай +4 очка за каждую цепочку из 4 клеток, где чередуются природные и жилые блоки."
  },
  {
    name: "Душа города",
    reward: 6,
    goal: 15,
    progress: 5,
    desc: "Получай +5 очков за каждую цепочку из 5 культурных блоков, соединённых по соседству или диагонали."
  }
];

const allQuests = quests;

function updateDeckCounter() {
  const counter = document.getElementById('deck-counter');
  counter.innerHTML = `В колоде:<br><br><span class="count">${deck.length}</span>`;
}

const eventLog = [];
const msgEventLogDiv = document.getElementById('msg-event-log');

function addLogMessage(text) {
  const msgEventLogDiv = document.getElementById('msg-event-log');

  const div = document.createElement('div');
  div.textContent = text;  // просто текст, без времени и счета
  msgEventLogDiv.appendChild(div);

  // автопрокрутка вниз
  msgEventLogDiv.scrollTop = msgEventLogDiv.scrollHeight;
}

// генерация случайной карты
function generateRandomCard() {
  const blocks = ["residential", "industrial", "nature", "culture"];
  for (let i = blocks.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [blocks[i], blocks[j]] = [blocks[j], blocks[i]];
  }
  return { name: "Новая карта", blocks };
}

for (let i = 0; i < initialHandSize; i++) deck.push(generateRandomCard());

function initActiveQuests() {
  const pool = [...allQuests];
  activeQuests = [];

  // выберем 3 случайных квеста
  for (let i = 0; i < 3 && pool.length > 0; i++) {
    const idx = Math.floor(Math.random() * pool.length);
    activeQuests.push({ ...pool[idx], progress: 0, completed: false });
    pool.splice(idx, 1);
  }
}
initActiveQuests();

// === Отображение квестов ===
function renderQuests() {
  const qDiv = document.getElementById('quests');
  qDiv.innerHTML = ''; // очищаем старые карточки

  activeQuests.forEach(q => {
    const card = document.createElement('div');
    card.className = 'quest-card';
    if (q.completed) card.classList.add('completed');

    card.style.position = 'relative'; // для бейджа награды

    const title = document.createElement('div');
    title.className = 'quest-title';
    title.textContent = q.name;

    const reward = document.createElement('div');
    reward.className = 'quest-reward-badge';
    reward.textContent = `${q.reward}`;
    reward.style.position = 'absolute';
    reward.style.top = '5px';
    reward.style.right = '5px';

    const desc = document.createElement('div');
    desc.className = 'quest-desc';
    desc.textContent = q.description || q.desc || '';

    const progressCont = document.createElement('div');
    progressCont.className = 'progress-container';

    const progress = document.createElement('div');
    progress.className = 'progress-bar';
    const perc = Math.min(100, (q.progress / q.goal) * 100);
    progress.style.width = perc + '%';
    progressCont.appendChild(progress);

    const progressText = document.createElement('div');
    progressText.className = 'progress-text';
    progressText.textContent = `${q.progress}/${q.goal}`;
    progressText.style.position = 'absolute';
    progressText.style.top = '50%';
    progressText.style.left = '50%';
    progressText.style.transform = 'translate(-50%, -50%)';
    progressText.style.fontSize = '12px';
    progressText.style.fontWeight = 'bold';
    progressText.style.pointerEvents = 'none';
    progressCont.appendChild(progressText);

    card.append(title, desc, reward, progressCont);
    qDiv.appendChild(card);
  });
}

renderQuests();
drawHand();
computeScore();

msgEventLogDiv.innerHTML = '';  // очистка лога

function drawHand() {
  while (hand.length < 3 && deck.length > 0) {
    const idx = Math.floor(Math.random() * deck.length);
    const newCard = deck.splice(idx, 1)[0];
    hand.push(newCard);
    cardRotations.push(0);
  }
  renderHand();
  updateDeckCounter();
}

function renderHand() {
  const handDiv = document.getElementById('hand');
  handDiv.innerHTML = '';
  hand.forEach((card, i) => {
    const cardDiv = document.createElement('div');
    cardDiv.className = 'card';
    card.blocks.forEach(b => {
      const blockDiv = document.createElement('div');
      blockDiv.className = 'block ' + b;
      blockDiv.textContent = b[0].toUpperCase();
      cardDiv.appendChild(blockDiv);
    });
    cardDiv.addEventListener('click', () => selectCard(i, cardDiv));
    if (i === selectedCardIndex) cardDiv.classList.add('selected');
    handDiv.appendChild(cardDiv);
  });
}


function selectCard(i, el) {
  selectedCardIndex = i;
  cardRotation = 0;
  document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
  el.classList.add('selected');
}

function highlightArea(x, y) {
  clearHighlights();
  if (selectedCardIndex === null) return;

  const card = hand[selectedCardIndex];
  const blocks = card.blocks;

  // используем getRotatedCoords чтобы учесть cardRotation
  const coords = [[x,y],[x+1,y],[x,y+1],[x+1,y+1]];
  coords.forEach(([nx, ny], idx) => {
    if (nx < gridSize && ny < gridSize) {
      const cell = gridDiv.children[ny * gridSize + nx];
      cell.classList.add('highlight');

      // Добавляем полноценный превью-блок (непрозрачный)
      const preview = document.createElement('div');
      preview.className = 'block-layer ' + blocks[idx] + ' preview';
      preview.textContent = blocks[idx][0].toUpperCase();
      preview.style.opacity = '1';
      preview.style.pointerEvents = 'none';
      cell.appendChild(preview);
    }
  });
}

function clearHighlights() {
  document.querySelectorAll('.cell').forEach(c => {
    c.classList.remove('highlight');
    c.querySelectorAll('.preview').forEach(p => p.remove());
  });
}

function getRotatedCoords(x, y) {
  const rel = [[0,0],[1,0],[0,1],[1,1]];
  return rel.map(([dx,dy]) => [x+dx, y+dy]); // просто ставим по текущему порядку блоков
}

function placeCard(x, y) {
  if (selectedCardIndex === null) return alert('Выберите карту');

  const coords = getRotatedCoords(x, y);
  if (coords.some(([nx,ny]) => nx < 0 || ny < 0 || nx >= gridSize || ny >= gridSize)) {
    alert('Не хватает места'); 
    return;
  }

  const card = hand[selectedCardIndex];
  let idx = 0;
  const newBlocks = [];
  coords.forEach(([nx,ny]) => {
    grid[ny][nx] = card.blocks[idx];
    updateCellVisual(nx, ny);
    newBlocks.push([nx, ny]);
    idx++;
  });

  hand.splice(selectedCardIndex, 1);
  cardRotations.splice(selectedCardIndex, 1);
  selectedCardIndex = null;

  drawHand();

  prevScore = lastScore;
  computeScore();
  checkCompletedQuests();
  checkGameEnd();
}

function updateCellVisual(x, y) {
  const cell = gridDiv.children[y * gridSize + x];
  cell.innerHTML = '';
  if (grid[y][x]) {
    const div = document.createElement('div');
    div.className = 'block-layer ' + grid[y][x];
    div.textContent = grid[y][x][0].toUpperCase();
    cell.appendChild(div);
  }
}

function highlightQuestText(text) {
  return text
    .replace(/жилой/gi, '<span class="residential-text">$&</span>')
    .replace(/парков/gi, '<span class="nature-text">$&</span>')
    .replace(/культур/gi, '<span class="culture-text">$&</span>')
    .replace(/промышленн/gi, '<span class="industrial-text">$&</span>');
}

function updateQuestProgressVisuals() {
  const qCards = document.querySelectorAll('.quest-card');
  activeQuests.forEach((q, i) => {
    const progressBar = qCards[i].querySelector('.progress-bar');
    const progressText = qCards[i].querySelector('.progress-text');
    if (!progressBar || !progressText) return;

    const perc = Math.min(100, (q.progress / q.goal) * 100);
    progressBar.style.width = perc + '%';
    progressText.textContent = `${q.progress}/${q.goal}`;

    if (q.completed) qCards[i].classList.add('completed');
  });
}

function computeScore() {
  let currentTotal = 0;

  activeQuests.forEach(q => {
    if (q.completed) return; // уже зафиксировано в savedPoints

    let bonus = 0;

    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        const block = grid[y][x];
        if (!block) continue;

        const neighbors = [
          [x - 1, y],
          [x + 1, y],
          [x, y - 1],
          [x, y + 1]
        ];

        const near = type => neighbors.some(([nx, ny]) =>
          nx >= 0 && ny >= 0 && nx < gridSize && ny < gridSize && grid[ny][nx] === type
        );

        switch (q.name) {
          case "Город в зелени":
            if (block === 'residential') bonus += near('nature') ? 2 : -2;
            break;

          case "Баланс индустрии":
            if (block === 'industrial') {
              const hasHouse = near('residential');
              const hasPark = near('nature');
              bonus += hasHouse && hasPark ? 2 : hasHouse && !hasPark ? -2 : 0;
            }
            break;

          case "Комфортные окраины":
            if (block === 'residential' && (x === 0 || y === 0 || x === gridSize - 1 || y === gridSize - 1)) {
              if (!near('industrial')) bonus += 2;
            }
            break;

case "Сердце культуры":
  if (block === 'culture') {
    const neighborsCoords = [
      [x-1, y], [x+1, y], [x, y-1], [x, y+1]
    ];
    const neighborTypes = new Set();
    neighborsCoords.forEach(([nx, ny]) => {
      if (nx >= 0 && ny >= 0 && nx < gridSize && ny < gridSize) {
        const b = grid[ny][nx];
        if (b) neighborTypes.add(b);
      }
    });
    // Проверяем, что соседствуют все 4 типа кварталов
    if (neighborTypes.has('residential') &&
        neighborTypes.has('industrial') &&
        neighborTypes.has('nature') &&
        neighborTypes.has('culture')) {
      bonus += 3;
    }
  }
  break;

          case "Пояс жизни":
            for (let dir of [[1,0],[0,1]]) {
              if (x + 3*dir[0] < gridSize && y + 3*dir[1] < gridSize) {
                let seq = [];
                for (let k = 0; k < 4; k++) seq.push(grid[y+k*dir[1]][x+k*dir[0]]);
                if (seq.join(',').match(/^(nature,residential|residential,nature)(,nature,residential|,residential,nature){1,}$/)) bonus += 4;
              }
            }
            break;

          case "Душа города":

            break;
        }
      }
    }

    q.progress = bonus;
    currentTotal += bonus;
  });

  const total = savedPoints + currentTotal;
  const diff = total - lastScore;
  lastScore = total;

  addLogMessage(`Начислено очков: ${diff>=0 ? '+'+diff : diff}.`);
  document.getElementById('score').textContent = `Очки: ${total}`;
  updateQuestProgressVisuals();
}

function replaceRandomQuest() {
  if (activeQuests.length === 0) return false;

  // убираем случайный квест из активных
  const oldQuestIndex = Math.floor(Math.random() * activeQuests.length);
  const oldQuest = activeQuests.splice(oldQuestIndex, 1)[0];
  completedQuests.push({ name: oldQuest.name, points: completedQuestPoints[oldQuest.name] });

  // берём новый квест случайно из оставшихся в allQuests
  const available = allQuests.filter(q =>
    !completedQuests.some(cq => cq.name === q.name) &&
    !activeQuests.some(aq => aq.name === q.name)
  );

if (available.length > 0) {
  const newQuest = available[Math.floor(Math.random() * available.length)];

  //Проверяем, не выполнялся ли этот квест раньше
  const old = activeQuests.find(q => q.name === newQuest.name && q.completed);
  if (old) savedPoints += old.progress; // фиксируем очки, чтобы не потерять

  //Добавляем новый экземпляр квеста
  activeQuests.push({ ...newQuest, progress: 0, completed: false });
}

  computeScore();
  renderQuests();
}


function checkGameEnd() {
  if (deck.length === 0 && hand.length === 0) alert("Игра окончена: карты закончились!");
  if (activeQuests.length === 0 && allQuests.length === completedQuests.length) alert("Поздравляем! Вы выполнили все квесты!");
}

// В обработке клавиш — вращаем выбранную карту: обновляем блоки, увеличиваем cardRotation и обновляем превью, если есть lastHover
document.addEventListener('keydown', e => {
  const key = e.key.toLowerCase();
  if ((key === 'r' || key === 'к') && selectedCardIndex !== null) {
    rotateCard(selectedCardIndex);
  }
});

function rotateCard(index) {
  const card = hand[index];
  const b = card.blocks;
  // поворот на 90° по часовой: меняем порядок блоков
  card.blocks = [b[2], b[0], b[3], b[1]];
  // запоминаем ориентацию для расчёта координат при размещении и превью
  cardRotation = (cardRotation + 1) % 4;
  renderHand();

  // обновляем превью на сетке, если карта выбрана и курсор над сеткой
  if (selectedCardIndex !== null && lastHoverX !== undefined && lastHoverY !== undefined) {
    highlightArea(lastHoverX, lastHoverY);
  }
}

function checkCompletedQuests() {
  for (let i = activeQuests.length - 1; i >= 0; i--) {
    const q = activeQuests[i];

    if (q.progress >= q.goal) {
      q.completed = true;
      savedPoints += q.progress; // фиксируем очки

      // выдаём карты как награду
      for (let j = 0; j < q.reward; j++) deck.push(generateRandomCard());

      completedQuests.push({ name: q.name, points: q.progress });
      activeQuests.splice(i, 1);

      addLogMessage(`Квест "${q.name}" выполнен! Получено карт: ${q.reward}.`);

      // добавляем новый квест
      const availableQuests = allQuests.filter(aq =>
    !completedQuests.some(cq => cq.name === aq.name) &&
    !activeQuests.some(aq2 => aq2.name === aq.name) // сравниваем имена разных объектов
);

      if (availableQuests.length > 0) {
        const idx = Math.floor(Math.random() * availableQuests.length);
        activeQuests.push({ ...availableQuests[idx], progress: 0, completed: false });
        addLogMessage(`Заменён квест на "${availableQuests[idx].name}"!`);
      }
    }
  }

  //computeScore();       // safe, savedPoints уже зафиксированы
  drawHand();           // обновляем руку
  updateDeckCounter();  // обновляем счетчик колоды
  renderQuests();
}



</script>

</body>
</html>
