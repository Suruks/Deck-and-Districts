<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Прототип карточного города</title>
<style>
body { font-family: sans-serif; text-align: center; }
#score { margin-top: 10px; font-size: 18px; }
#info { margin-top: 10px; font-size: 16px; }
#quests { margin-top: 10px; text-align: left; display: inline-block; }
#grid {
  display: grid;
  grid-template-columns: repeat(10, 40px);
  grid-gap: 2px;
  justify-content: center;
  margin-top: 20px;
  width: max-content;
  margin-left: auto;
  margin-right: auto;
}
.preview {position: absolute;inset: 0;pointer-events: none;}
.cell { width: 40px; height: 40px; border: 1px solid #aaa; display: flex; align-items: center; justify-content: center; font-size: 10px; position: relative; }
.highlight { outline: 3px solid yellow; }
.block-layer { position: absolute; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 9px; }
.residential { background: #8fd18f; }
.industrial { background: #d18f8f; }
.nature { background: #8fc3d1; }
.culture { background: #d1c08f; }
#hand { margin-top: 20px; display: flex; justify-content: center; }
.card { width: 80px; height: 80px; margin: 0 5px; cursor: pointer; border: 2px solid #333; display: flex; flex-wrap: wrap; transition: transform 0.2s ease; transform-origin: center center;}
.block { width: 40px; height: 40px; box-sizing: border-box; border: 1px solid #555; display: flex; align-items: center; justify-content: center; font-size: 9px; }
.selected { border-color: red; }
.residential-text { color: #0b5; font-weight: bold; }
.industrial-text { color: #b33; font-weight: bold; }
.nature-text { color: #09c; font-weight: bold; }
.culture-text { color: #c90; font-weight: bold; }
#message { margin-top: 10px; font-size: 16px; min-height: 30px; }

/* === styles for quest cards (added) === */
#left-panel {
  width: 260px;
  display: inline-block;
  vertical-align: top;
  text-align: left;
  margin-right: 20px;
}
#quests {
  display: flex;
  flex-direction: column;
  gap: 15px;
}
.quest-card {
  position: relative; /* <-- это нужно для абсолютного бейджа */
  border: 2px solid #555;
  border-radius: 10px;
  padding: 10px;
  background: #f4f4f4;
  box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
}
.quest-title { font-weight: bold; margin-bottom: 5px; }
.quest-reward { font-size: 12px; color: #090; }
.quest-desc { font-size: 13px; margin-bottom: 8px; }
.progress-container { width: 100%; height: 16px; background: #ddd; border-radius: 6px; overflow: hidden; position: relative; }
.progress-bar { height: 100%; background: linear-gradient(90deg, #3c8, #4c4); width: 0%; transition: width 0.3s ease; }
.completed { border-color: gold; background: #fffbe0; }
.quest-reward-badge {
  position: absolute;
  top: 5px;
  right: 5px;
  background: gold;
  color: black;
  font-weight: bold;
  border-radius: 50%;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
  pointer-events: none;
}

#hand-wrapper {
  display: flex;
  justify-content: center;
  align-items: center; /* центрируем колоду и рукав по высоте */
  gap: 20px;
}

#deck-counter {
  display: flex;
  flex-direction: column; /* если нужен текст сверху/цифра снизу */
  justify-content: center; /* центрируем контент внутри */
  align-items: center;
  flex-shrink: 0; /* не сжимать */
  width: 80px;
  height: 80px;
  border: 2px dashed #555;
  border-radius: 8px;
  background: #fafafa;
  color: #333;
  font-size: 14px;
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  line-height: 1;
  transform: translateY(10px); /* подогнать визуально */
}

#deck-counter * {
  margin: 0;
  padding: 0;
  line-height: 1; /* гарантируем отсутствие смещений текста */
}

#hand {
  display: flex;
  gap: 5px;
  align-items: center; /* центрируем карты по вертикали */
}




#deck-counter span.count {
  font-size: 24px;  /* большая цифра */
  font-weight: bold;
  line-height: 1;
}


</style>
</head>
<body>

<h1>Прототип карточного города</h1>
<div id="left-panel">
  <h3>Квесты</h3>
  <div id="quests"></div>
</div>
<div style="display:inline-block; vertical-align: top;">
  <div id="score">Очки: 0</div>
  <div id="info"></div>
  <div id="grid"></div>
  <h3>Рука</h3>
  <div id="hand-wrapper">
  <div id="deck-counter">В колоде: 0</div>
  <div id="hand"></div>
</div>

<div id="message">
  <div id="msg-event-log" style="max-height: 200px; overflow-y: auto;"></div>
</div>
</div>

<script>
const gridSize = 10;
let grid = Array.from({length: gridSize}, () => Array.from({length: gridSize}, () => null));
const gridDiv = document.getElementById('grid');

let lastHoverX, lastHoverY; // хранит последнюю ячейку, на которой был курсор

for (let y = 0; y < gridSize; y++) {
  for (let x = 0; x < gridSize; x++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.dataset.x = x;
    cell.dataset.y = y;
    gridDiv.appendChild(cell);
    cell.addEventListener('mouseenter', () => {
      lastHoverX = x; lastHoverY = y;
      highlightArea(x, y);
    });
    cell.addEventListener('mouseleave', () => {
      clearHighlights();
      // оставляем lastHoverX/Y, чтобы можно было обновить превью при повороте
    });
    cell.addEventListener('click', () => placeCard(x, y));
  }
}

let selectedCardIndex = null;
let cardRotation = 0; // глобальная ориентация текущей выбранной карты (0..3)
let cardRotations = []; // индивидуальные повороты карт в руке (не обязателен, но оставлен)
let deck = [];
let hand = [];
let activeQuests = [];
let completedQuests = [];
let completedQuestPoints = {};
let lastScore = 0;
let prevScore = 0;
let nextCardThreshold = 3;
let nextQuestThreshold = 10;
const msgScore = document.getElementById('msg-score');
const msgEvent = document.getElementById('msg-event');

const initialHandSize = 16;
const allQuests = [
  { name: "Парковый уют", description: "Каждый жилой блок рядом с парком дает +1 очко", type: "positive", goal: 6, progress: 0, reward: 2, completed: false },
  { name: "Комбо культурных", description: "Каждый культурный блок рядом с другим культурным блоком дает +1 очко", type: "positive", goal: 6, progress: 0, reward: 2, completed: false },
  { name: "Жилые на краю", description: "Каждый жилой блок на краю поля +1 очко", type: "positive", goal: 6, progress: 0, reward: 1, completed: false },
  { name: "Заводы вместе", description: "Каждый промышленный блок рядом с другим промышленным +1 очко", type: "positive", goal: 6, progress: 0, reward: 1, completed: false },
  { name: "Индустриальный штраф", description: "Если промышленных блоков больше 6, каждый лишний -1 очко", type: "negative", goal: 8, progress: 0, reward: 0, completed: false },
  { name: "Индустриальный край", description: "Каждый промышленный блок на краю -1 очко", type: "negative", goal: 6, progress: 0, reward: 0, completed: false }
];

// визуальные квесты (отдельно, для карточек)
const quests = [
  {
    name: "Город в зелени",
    reward: 4,
    goal: 10,
    progress: 0,
    desc: "За каждый дом, соседствующий с парком, +2 очка. За дом без парка рядом — −1 очко."
  },
  {
    name: "Баланс индустрии",
    reward: 4,
    goal: 12,
    progress: 0,
    desc: "Заводы приносят по +2 очка, если рядом хотя бы один дом и один парк. Если рядом только дома — −2 очка."
  },
  {
    name: "Комфортные окраины",
    reward: 4,
    goal: 10,
    progress: 0,
    desc: "Дома на краю поля дают +2 очка, но только если не касаются заводов."
  },
  {
    name: "Сердце культуры",
    reward: 6,
    goal: 15,
    progress: 2,
    desc: "Получай +3 очка за каждый культурный блок, соседствующий со всеми 4-мя видами кварталов."
  },
  {
    name: "Пояс жизни",
    reward: 4,
    goal: 12,
    progress: 8,
    desc: "Получай +4 очка за каждую цепочку из 4 клеток, где чередуются природные и жилые блоки."
  },
  {
    name: "Душа города",
    reward: 6,
    goal: 15,
    progress: 5,
    desc: "Получай +5 очков за каждую цепочку из 5 культурных блоков, соединённых по соседству или диагонали."
  }
];

function updateDeckCounter() {
  const counter = document.getElementById('deck-counter');
  counter.innerHTML = `В колоде:<br><br><span class="count">${deck.length}</span>`;
}

const eventLog = [];
const msgEventLogDiv = document.getElementById('msg-event-log');

function addLogMessage(text) {
  const msgEventLogDiv = document.getElementById('msg-event-log');

  const div = document.createElement('div');
  div.textContent = text;  // просто текст, без времени и счета
  msgEventLogDiv.appendChild(div);

  // автопрокрутка вниз
  msgEventLogDiv.scrollTop = msgEventLogDiv.scrollHeight;
}

// генерация случайной карты
function generateRandomCard() {
  const blocks = ["residential", "industrial", "nature", "culture"];
  for (let i = blocks.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [blocks[i], blocks[j]] = [blocks[j], blocks[i]];
  }
  return { name: "Новая карта", blocks };
}

for (let i = 0; i < 8; i++) deck.push(generateRandomCard());

function initActiveQuests() {
  const positives = allQuests.filter(q => q.type === "positive");
  const negatives = allQuests.filter(q => q.type === "negative");
  activeQuests = [];
  for (let i = 0; i < 2; i++) {
    const idx = Math.floor(Math.random() * positives.length);
    activeQuests.push(positives.splice(idx, 1)[0]);
  }
  const idx = Math.floor(Math.random() * negatives.length);
  activeQuests.push(negatives[idx]);
}
initActiveQuests();

// === Отображение квестов ===
function renderQuests() {
  const qDiv = document.getElementById('quests');
  qDiv.innerHTML = ''; // очищаем старые карточки

  activeQuests.forEach(q => {
    const card = document.createElement('div');
    card.className = 'quest-card';
    if (q.completed) card.classList.add('completed');

    card.style.position = 'relative'; // для бейджа награды

    const title = document.createElement('div');
    title.className = 'quest-title';
    title.textContent = q.name;

    const reward = document.createElement('div');
    reward.className = 'quest-reward-badge';
    reward.textContent = `${q.reward}`;
    reward.style.position = 'absolute';
    reward.style.top = '5px';
    reward.style.right = '5px';

    const desc = document.createElement('div');
    desc.className = 'quest-desc';
    desc.textContent = q.description || q.desc || '';

    const progressCont = document.createElement('div');
    progressCont.className = 'progress-container';

    const progress = document.createElement('div');
    progress.className = 'progress-bar';
    const perc = Math.min(100, (q.progress / q.goal) * 100);
    progress.style.width = perc + '%';
    progressCont.appendChild(progress);

    const progressText = document.createElement('div');
    progressText.className = 'progress-text';
    progressText.textContent = `${q.progress}/${q.goal}`;
    progressText.style.position = 'absolute';
    progressText.style.top = '50%';
    progressText.style.left = '50%';
    progressText.style.transform = 'translate(-50%, -50%)';
    progressText.style.fontSize = '12px';
    progressText.style.fontWeight = 'bold';
    progressText.style.pointerEvents = 'none';
    progressCont.appendChild(progressText);

    card.append(title, desc, reward, progressCont);
    qDiv.appendChild(card);
  });
}

renderQuests();
drawHand();
computeScore();

msgEventLogDiv.innerHTML = '';  // очистка лога

function drawHand() {
  while (hand.length < 3 && deck.length > 0) {
    const idx = Math.floor(Math.random() * deck.length);
    const newCard = deck.splice(idx, 1)[0];
    hand.push(newCard);
    cardRotations.push(0);
  }
  renderHand();
  updateDeckCounter();
}

function renderHand() {
  const handDiv = document.getElementById('hand');
  handDiv.innerHTML = '';
  hand.forEach((card, i) => {
    const cardDiv = document.createElement('div');
    cardDiv.className = 'card';
    card.blocks.forEach(b => {
      const blockDiv = document.createElement('div');
      blockDiv.className = 'block ' + b;
      blockDiv.textContent = b[0].toUpperCase();
      cardDiv.appendChild(blockDiv);
    });
    cardDiv.addEventListener('click', () => selectCard(i, cardDiv));
    if (i === selectedCardIndex) cardDiv.classList.add('selected');
    handDiv.appendChild(cardDiv);
  });
}


function selectCard(i, el) {
  selectedCardIndex = i;
  cardRotation = 0;
  document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
  el.classList.add('selected');
}

function highlightArea(x, y) {
  clearHighlights();
  if (selectedCardIndex === null) return;

  const card = hand[selectedCardIndex];
  const blocks = card.blocks;

  // используем getRotatedCoords чтобы учесть cardRotation
  const coords = [[x,y],[x+1,y],[x,y+1],[x+1,y+1]];
  coords.forEach(([nx, ny], idx) => {
    if (nx < gridSize && ny < gridSize) {
      const cell = gridDiv.children[ny * gridSize + nx];
      cell.classList.add('highlight');

      // Добавляем полноценный превью-блок (непрозрачный)
      const preview = document.createElement('div');
      preview.className = 'block-layer ' + blocks[idx] + ' preview';
      preview.textContent = blocks[idx][0].toUpperCase();
      preview.style.opacity = '1';
      preview.style.pointerEvents = 'none';
      cell.appendChild(preview);
    }
  });
}

function clearHighlights() {
  document.querySelectorAll('.cell').forEach(c => {
    c.classList.remove('highlight');
    c.querySelectorAll('.preview').forEach(p => p.remove());
  });
}

function getRotatedCoords(x, y) {
  const rel = [[0,0],[1,0],[0,1],[1,1]];
  return rel.map(([dx,dy]) => [x+dx, y+dy]); // просто ставим по текущему порядку блоков
}

function placeCard(x, y) {
  if (selectedCardIndex === null) return alert('Выберите карту');

  const coords = getRotatedCoords(x, y);
  if (coords.some(([nx,ny]) => nx < 0 || ny < 0 || nx >= gridSize || ny >= gridSize)) {
    alert('Не хватает места'); 
    return;
  }

  const card = hand[selectedCardIndex];
  let idx = 0;
  const newBlocks = [];
  coords.forEach(([nx,ny]) => {
    grid[ny][nx] = card.blocks[idx];
    updateCellVisual(nx, ny);
    newBlocks.push([nx, ny]);
    idx++;
  });

  hand.splice(selectedCardIndex, 1);
  cardRotations.splice(selectedCardIndex, 1);
  selectedCardIndex = null;

  drawHand();

  prevScore = lastScore;
  computeScore();
  checkCompletedQuests();
  checkGameEnd();
}

function updateCellVisual(x, y) {
  const cell = gridDiv.children[y * gridSize + x];
  cell.innerHTML = '';
  if (grid[y][x]) {
    const div = document.createElement('div');
    div.className = 'block-layer ' + grid[y][x];
    div.textContent = grid[y][x][0].toUpperCase();
    cell.appendChild(div);
  }
}

function highlightQuestText(text) {
  return text
    .replace(/жилой/gi, '<span class="residential-text">$&</span>')
    .replace(/парков/gi, '<span class="nature-text">$&</span>')
    .replace(/культур/gi, '<span class="culture-text">$&</span>')
    .replace(/промышленн/gi, '<span class="industrial-text">$&</span>');
}

function updateQuestProgressVisuals() {
  const qCards = document.querySelectorAll('.quest-card');
  activeQuests.forEach((q, i) => {
    const progressBar = qCards[i].querySelector('.progress-bar');
    const progressText = qCards[i].querySelector('.progress-text');
    if (!progressBar || !progressText) return;

    const perc = Math.min(100, (q.progress / q.goal) * 100);
    progressBar.style.width = perc + '%';
    progressText.textContent = `${q.progress}/${q.goal}`;

    if (q.completed) qCards[i].classList.add('completed');
  });
}


function computeScore() {
  let currentTotal = 0;

  activeQuests.forEach(q => {
    let bonus = 0;

    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        const block = grid[y][x];
        if (!block) continue;

        const neighbors = [[x-1,y],[x+1,y],[x,y-1],[x,y+1]];

        if (q.name === 'Парковый уют' && block === 'residential') { 
          if (neighbors.some(([nx,ny]) => nx>=0 && ny>=0 && nx<gridSize && ny<gridSize && grid[ny][nx]==='nature')) bonus++; 
        }
        if (q.name === 'Комбо культурных' && block === 'culture') { 
          if (neighbors.some(([nx,ny]) => nx>=0 && ny>=0 && nx<gridSize && ny<gridSize && grid[ny][nx]==='culture')) bonus++; 
        }
        if (q.name === 'Жилые на краю' && block==='residential'&&(x===0||y===0||x===gridSize-1||y===gridSize-1)) bonus++;
        if (q.name === 'Заводы вместе' && block==='industrial') {
          if (neighbors.some(([nx,ny]) => nx>=0 && ny>=0 && nx<gridSize && ny<gridSize && grid[ny][nx]==='industrial')) bonus++;
        }
        if (q.name === 'Индустриальный край' && block==='industrial'&&(x===0||y===0||x===gridSize-1||y===gridSize-1)) bonus--;
      }
    }

    completedQuestPoints[q.name] = bonus;
    q.progress = bonus; 
    currentTotal += bonus;
  });

  const diff = currentTotal + completedQuests.reduce((sum,q)=>sum+q.points,0) - lastScore;
  lastScore = currentTotal + completedQuests.reduce((sum,q)=>sum+q.points,0);

  addLogMessage(diff >= 0 ? `Начислено очков: +${diff}.` : `Начислено очков: ${diff}.`);

  updateQuestProgressVisuals();
}


function replaceRandomQuest() {
  if (activeQuests.length === 0) return false;
  const oldQuestIndex = Math.floor(Math.random() * activeQuests.length);
  const oldQuest = activeQuests.splice(oldQuestIndex, 1)[0];
  completedQuests.push({ name: oldQuest.name, points: completedQuestPoints[oldQuest.name] });

  const positives = allQuests.filter(q => q.type==='positive' && !completedQuests.some(cq => cq.name===q.name) && !activeQuests.some(aq => aq.name===q.name));
  const negatives = allQuests.filter(q => q.type==='negative' && !completedQuests.some(cq => cq.name===q.name) && !activeQuests.some(aq => aq.name===q.name));

  let newQuest = null;
  if (oldQuest.type === 'positive' && positives.length > 0) {
    const idx = Math.floor(Math.random() * positives.length);
    newQuest = positives[idx];
  } else if (oldQuest.type === 'negative' && negatives.length > 0) {
    const idx = Math.floor(Math.random() * negatives.length);
    newQuest = negatives[idx];
  }

  if (newQuest) activeQuests.push(newQuest);
  computeScore();
  return !!newQuest;
}

function checkGameEnd() {
  if (deck.length === 0 && hand.length === 0) alert("Игра окончена: карты закончились!");
  if (activeQuests.length === 0 && allQuests.length === completedQuests.length) alert("Поздравляем! Вы выполнили все квесты!");
}

// В обработке клавиш — вращаем выбранную карту: обновляем блоки, увеличиваем cardRotation и обновляем превью, если есть lastHover
document.addEventListener('keydown', e => {
  const key = e.key.toLowerCase();
  if ((key === 'r' || key === 'к') && selectedCardIndex !== null) {
    rotateCard(selectedCardIndex);
  }
});

function rotateCard(index) {
  const card = hand[index];
  const b = card.blocks;
  // поворот на 90° по часовой: меняем порядок блоков
  card.blocks = [b[2], b[0], b[3], b[1]];
  // запоминаем ориентацию для расчёта координат при размещении и превью
  cardRotation = (cardRotation + 1) % 4;
  renderHand();

  // обновляем превью на сетке, если карта выбрана и курсор над сеткой
  if (selectedCardIndex !== null && lastHoverX !== undefined && lastHoverY !== undefined) {
    highlightArea(lastHoverX, lastHoverY);
  }
}

function checkCompletedQuests() {

  for (let i = activeQuests.length - 1; i >= 0; i--) {
    const q = activeQuests[i];

    if (q.progress >= q.goal) {
      q.completed = true;

      // начисляем карты как награду
      for (let j = 0; j < q.reward; j++) {
        const newCard = generateRandomCard();
        deck.push(newCard);
      }

      completedQuests.push({ name: q.name, points: completedQuestPoints[q.name] });
      activeQuests.splice(i, 1);

      addLogMessage(`Квест "${q.name}" выполнен! Получено карт: ${q.reward}.`);

      // добавляем новый квест
      let availableQuests = allQuests.filter(aq =>
        !completedQuests.some(cq => cq.name === aq.name) &&
        !activeQuests.some(aq2 => aq2.name === aq.name)
      );

      if (availableQuests.length === 0 && completedQuests.length > 0) {
        // сброс завершённых квестов
        completedQuests.forEach(cq => {
          const original = allQuests.find(aq => aq.name === cq.name);
          if (original) {
            original.progress = 0;
            original.completed = false;
          }
        });
        completedQuests.length = 0;
        availableQuests = allQuests.filter(aq => !activeQuests.some(aq2 => aq2.name === aq.name));
        addLogMessage("Колода квестов обновлена, завершённые квесты возвращены!");
      }

      if (availableQuests.length > 0) {
        const idx = Math.floor(Math.random() * availableQuests.length);
        activeQuests.push(availableQuests[idx]);
        addLogMessage(`Заменён квест на "${availableQuests[idx].name}"!`);
      }

      computeScore();
    }
  }

  drawHand();          // обновляем руку, если есть место
  updateDeckCounter(); // обновляем счетчик колоды
  renderQuests();
}



</script>

</body>
</html>
